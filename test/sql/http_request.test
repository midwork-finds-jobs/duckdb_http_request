# name: test/sql/http_request.test
# description: test http_request extension
# group: [sql]

# Before we load the extension, this will fail
statement error
SELECT http_get('https://example.com/');
----
Catalog Error: Scalar Function with name http_get does not exist!

# Require statement will ensure this test is run with this extension loaded
require http_request

# httpfs provides https support
require httpfs

#------------------------------------------------------------------------------
# byte_range helper function
#------------------------------------------------------------------------------

query I
SELECT byte_range(0, 100);
----
bytes=0-99

query I
SELECT byte_range(727608633, 1278);
----
bytes=727608633-727609910

query I
SELECT byte_range(1000, 1);
----
bytes=1000-1000

#------------------------------------------------------------------------------
# http_get scalar function
#------------------------------------------------------------------------------

# Basic GET returns struct with status, headers, body
query I
SELECT http_get('https://example.com/').status;
----
200

# Body is returned as BLOB
query I
SELECT octet_length(http_get('https://example.com/').body) > 0;
----
true

# Headers are returned as MAP
query I
SELECT http_get('https://example.com/').headers['Content-Type'] IS NOT NULL;
----
true

# GET with custom headers (httpbin may return 502 occasionally, just check it's not 0)
query I
SELECT http_get('https://httpbin.org/get', {'Accept': 'application/json'}).status > 0;
----
true

#------------------------------------------------------------------------------
# http_head scalar function
#------------------------------------------------------------------------------

query I
SELECT http_head('https://example.com/').status;
----
200

# HEAD returns empty body
query I
SELECT octet_length(http_head('https://example.com/').body);
----
0

# HEAD with custom headers (httpbin may return 502 occasionally)
query I
SELECT http_head('https://httpbin.org/get', {'Accept': 'application/json'}).status > 0;
----
true

#------------------------------------------------------------------------------
# http_get table function
#------------------------------------------------------------------------------

query I
SELECT status FROM http_get('https://example.com/');
----
200

query I
SELECT octet_length(body) > 0 FROM http_get('https://example.com/');
----
true

# Table function with named headers parameter (httpbin may return 502 occasionally)
query I
SELECT status > 0 FROM http_get('https://httpbin.org/get', headers := {'Accept': 'application/json'});
----
true

#------------------------------------------------------------------------------
# http_head table function
#------------------------------------------------------------------------------

query I
SELECT status FROM http_head('https://example.com/');
----
200

query I
SELECT octet_length(body) FROM http_head('https://example.com/');
----
0

# Table function with named headers parameter (httpbin may return 502 occasionally)
query I
SELECT status > 0 FROM http_head('https://httpbin.org/get', headers := {'Accept': 'text/html'});
----
true

#------------------------------------------------------------------------------
# Byte range requests (HTTP 206 Partial Content)
#------------------------------------------------------------------------------

# Using byte_range helper in headers struct (allow 503 for temp service unavailable)
query I
SELECT http_get(
    'https://data.commoncrawl.org/crawl-data/CC-MAIN-2024-46/segments/1730477027552.27/warc/CC-MAIN-20241101184224-20241101214224-00238.warc.gz',
    {'Range': byte_range(727608633, 1278)}
).status IN (206, 503);
----
true

# Auto-decompresses gzip, body should be larger than requested range (or 0 if 503)
query I
SELECT octet_length(http_get(
    'https://data.commoncrawl.org/crawl-data/CC-MAIN-2024-46/segments/1730477027552.27/warc/CC-MAIN-20241101184224-20241101214224-00238.warc.gz',
    {'Range': byte_range(727608633, 1278)}
).body) > 1278 OR octet_length(http_get(
    'https://data.commoncrawl.org/crawl-data/CC-MAIN-2024-46/segments/1730477027552.27/warc/CC-MAIN-20241101184224-20241101214224-00238.warc.gz',
    {'Range': byte_range(727608633, 1278)}
).body) = 0;
----
true

# Table function with byte range (allow 503 for temp service unavailable)
query I
SELECT status IN (206, 503) FROM http_get(
    'https://data.commoncrawl.org/crawl-data/CC-MAIN-2024-46/segments/1730477027552.27/warc/CC-MAIN-20241101184224-20241101214224-00238.warc.gz',
    headers := {'Range': byte_range(727608633, 1278)}
);
----
true

#------------------------------------------------------------------------------
# http_follow_redirects setting
#------------------------------------------------------------------------------

# Disable cache to test redirect setting changes properly
statement ok
SET http_request_cache = false;

# Default: follows redirects (httpbin may return 502, so allow status > 0)
query I
SELECT http_get('https://httpbin.org/redirect/1').status IN (200, 502);
----
true

# Check setting exists and is default true
query I
SELECT current_setting('http_follow_redirects')::BOOLEAN;
----
true

# Disable redirects: returns 302 with Location header
statement ok
SET http_follow_redirects = false;

# Verify setting changed
query I
SELECT current_setting('http_follow_redirects')::BOOLEAN;
----
false

# With redirects disabled, should return 302 (or 502 if httpbin has issues)
query I
SELECT http_get('https://httpbin.org/redirect/1').status IN (302, 502);
----
true

# Location header should point to final destination (when not 502)
query I
SELECT http_get('https://httpbin.org/redirect/1').headers['Location'] IS NOT NULL OR http_get('https://httpbin.org/redirect/1').status = 502;
----
true

# Re-enable redirects
statement ok
SET http_follow_redirects = true;

query I
SELECT http_get('https://httpbin.org/redirect/1').status IN (200, 502);
----
true

# Re-enable cache
statement ok
SET http_request_cache = true;

#------------------------------------------------------------------------------
# Case-insensitive header access
#------------------------------------------------------------------------------

# Headers are normalized to Title-Case (Content-Type, not content-type)
query I
SELECT http_get('https://example.com/').headers['Content-Type'] IS NOT NULL;
----
true

# http_header() function for case-insensitive lookup
query I
SELECT http_header(http_get('https://example.com/'), 'content-type') IS NOT NULL;
----
true

# http_header() works with any case
query I
SELECT http_header(http_get('https://example.com/'), 'CONTENT-TYPE') IS NOT NULL;
----
true

# http_header() returns same value regardless of case
query I
SELECT http_header(r, 'content-type') = http_header(r, 'Content-Type')
FROM (SELECT http_get('https://example.com/') as r);
----
true
